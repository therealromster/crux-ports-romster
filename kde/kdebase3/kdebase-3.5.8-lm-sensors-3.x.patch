diff -up kdebase-3.5.8/ksysguard/ksysguardd/Linux/lmsensors.c.lmsens3x kdebase-3.5.8/ksysguard/ksysguardd/Linux/lmsensors.c
--- kdebase-3.5.8/ksysguard/ksysguardd/Linux/lmsensors.c.lmsens3x	2005-10-10 17:04:31.000000000 +0200
+++ kdebase-3.5.8/ksysguard/ksysguardd/Linux/lmsensors.c	2008-01-01 22:05:09.000000000 +0100
@@ -36,7 +36,12 @@ typedef struct
 {
   char* fullName;
   const sensors_chip_name* scn;
+#if SENSORS_API_VERSION & 0x400
+  const sensors_feature *sf;
+  const sensors_subfeature *sfd;
+#else
   const sensors_feature_data* sfd;
+#endif
 } LMSENSOR;
 
 static CONTAINER LmSensors;
@@ -65,6 +70,82 @@ static LMSENSOR* findMatchingSensor( con
   return s;
 }
 
+#if SENSORS_API_VERSION & 0x400
+void initLmSensors( struct SensorModul* sm )
+{
+  const sensors_chip_name* scn;
+  int nr = 0;
+
+  if ( sensors_init( NULL ) ) {
+    LmSensorsOk = -1;
+    return;
+  }
+
+  LmSensors = new_ctnr();
+  while ( ( scn = sensors_get_detected_chips( NULL, &nr ) ) != NULL ) {
+    int nr1 = 0;
+    const sensors_feature* sf;
+
+    while ( ( sf = sensors_get_features( scn, &nr1 ) ) != 0 ) {
+      const sensors_subfeature *ssubf;
+      LMSENSOR *p;
+      char *s, *label;
+      
+      switch( sf->type )
+      {
+        case SENSORS_FEATURE_IN:
+          ssubf = sensors_get_subfeature( scn, sf,
+                                          SENSORS_SUBFEATURE_IN_INPUT );
+          break;
+    
+        case SENSORS_FEATURE_FAN:
+          ssubf = sensors_get_subfeature( scn, sf,
+                                          SENSORS_SUBFEATURE_FAN_INPUT );
+          break;
+    
+        case SENSORS_FEATURE_TEMP:
+          ssubf = sensors_get_subfeature( scn, sf,
+                                          SENSORS_SUBFEATURE_TEMP_INPUT );
+          break;
+      }
+      
+      if ( !ssubf )
+        continue;
+
+      label = sensors_get_label( scn, sf );
+      p = (LMSENSOR*)malloc( sizeof( LMSENSOR ) );
+      p->fullName = (char*)malloc( strlen( "lmsensors/" ) +
+                                   strlen( scn->prefix ) + 1 +
+                                   strlen( label ) + 1 );
+      sprintf( p->fullName, "lmsensors/%s/%s", scn->prefix, label );
+
+      /* Make sure that name contains only proper characters. */
+      for ( s = p->fullName; *s; s++ )
+        if ( *s == ' ' )
+          *s = '_';
+
+      p->scn = scn;
+      p->sf = sf;
+      p->sfd = ssubf;
+
+      /* Note a name collision should never happen with the lm_sensors-3x code,
+         but it does in the case of k8temp, when there are 2 identical labeled
+         sensors per CPU. This are really 2 distinct sensors measuring the
+         same thing, but fullName must be unique so we just drop the second
+         sensor */
+      if ( search_ctnr( LmSensors, sensorCmp, p ) < 0 ) {
+        push_ctnr( LmSensors, p );
+        registerMonitor( p->fullName, "float", printLmSensor, printLmSensorInfo, sm );
+      } else {
+        free( p->fullName );
+        free( p );
+      }
+      free( label );
+    }
+  }
+  bsort_ctnr( LmSensors, sensorCmp );
+}
+#else /* SENSORS_API_VERSION & 0x400 */
 void initLmSensors( struct SensorModul* sm )
 {
   const sensors_chip_name* scn;
@@ -117,11 +198,13 @@ void initLmSensors( struct SensorModul* 
           free( p->fullName );
           free( p );
         }
+        free( label );
       }
     }
   }
   bsort_ctnr( LmSensors, sensorCmp );
 }
+#endif /* SENSORS_API_VERSION & 0x400 */
 
 void exitLmSensors( void )
 {
@@ -137,8 +220,11 @@ void printLmSensor( const char* cmd )
     fprintf( CurrentClient, "0\n" );
     return;
   }
-
+#if SENSORS_API_VERSION & 0x400
+  sensors_get_value( s->scn, s->sfd->number, &value );
+#else
   sensors_get_feature( *(s->scn), s->sfd->number, &value );
+#endif
   fprintf( CurrentClient, "%f\n", value );
 }
 
